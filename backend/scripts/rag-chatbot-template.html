<!DOCTYPE html>
<html lang="{{app_settings.language}}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{app_settings.app_title}}</title>
    <style>
        :root {
            --primary-color: {{styling.primary_color}};
            --secondary-color: {{styling.secondary_color}};
            --background-color: {{styling.background_color}};
            --text-color: {{styling.text_color}};
            --light-bg-color: {{styling.light_bg_color}};
            --border-color: {{styling.border_color}};
            --font-family: {{styling.font_family}};
            --font-size-small: {{styling.font_size_small}};
            --font-size-medium: {{styling.font_size_medium}};
            --font-size-large: {{styling.font_size_large}};
            --border-radius: {{styling.border_radius}};
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .app-title {
            font-size: var(--font-size-large);
            font-weight: bold;
            color: var(--primary-color);
        }

        .app-description {
            font-size: var(--font-size-small);
            color: var(--text-color);
            opacity: 0.8;
            margin-top: 5px;
        }

        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .content-header {
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: white;
        }

        .content-title {
            font-size: var(--font-size-medium);
            font-weight: bold;
        }

        .quick-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px 20px;
            background-color: var(--light-bg-color);
            border-bottom: 1px solid var(--border-color);
        }

        .quick-action {
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 8px 15px;
            font-size: var(--font-size-small);
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-action:hover {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .chat-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 80%;
            padding: 12px 15px;
            border-radius: var(--border-radius);
            font-size: var(--font-size-medium);
            line-height: 1.5;
        }

        .ai-message {
            align-self: flex-start;
            background-color: var(--light-bg-color);
            border-bottom-left-radius: 0;
        }

        .user-message {
            align-self: flex-end;
            background-color: var(--primary-color);
            color: white;
            border-bottom-right-radius: 0;
        }

        /* Source citation styles */
        .sources-container {
            margin-top: 10px;
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            font-size: var(--font-size-small);
        }

        .sources-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: var(--primary-color);
            font-weight: 500;
            margin-bottom: 5px;
        }

        .sources-toggle:hover {
            text-decoration: underline;
        }

        .sources-list {
            display: none;
            margin-left: 5px;
        }

        .sources-list.expanded {
            display: block;
        }

        .source-item {
            margin-bottom: 8px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: var(--border-radius);
            cursor: pointer;
        }

        .source-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .source-name {
            font-weight: 500;
            color: var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .source-content {
            white-space: pre-wrap;
            font-family: var(--font-family);
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .source-content code {
            background-color: rgba(0, 0, 0, 0.05);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }

        .source-chunks-container {
            display: none;
            margin-top: 8px;
        }

        .source-chunks-container.expanded {
            display: block;
        }

        .source-chunk {
            margin-bottom: 8px;
            padding: 8px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
        }

        .chunk-header {
            font-weight: 500;
            color: var(--primary-color);
            margin-bottom: 5px;
            font-size: 12px;
        }

        .sources-explanation {
            margin-bottom: 12px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.02);
            border-radius: var(--border-radius);
            font-size: 13px;
            color: var(--text-color);
            line-height: 1.4;
        }

        .input-container {
            display: flex;
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
            background-color: white;
        }

        .chat-input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius) 0 0 var(--border-radius);
            font-size: var(--font-size-medium);
            outline: none;
        }

        .chat-input:focus {
            border-color: var(--primary-color);
        }

        .send-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            padding: 0 20px;
            font-size: var(--font-size-medium);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .send-button:hover {
            background-color: var(--secondary-color);
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            font-size: var(--font-size-small);
            color: var(--text-color);
            opacity: 0.7;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                height: 100vh;
            }

            .quick-actions {
                padding: 10px;
            }

            .message {
                max-width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <div class="app-title">{{app_settings.app_title}}</div>
                <div class="app-description">{{app_settings.app_description}}</div>
            </div>
        </div>

        <!-- Content section -->
        <div class="content">
            <div class="content-header">
                <div class="content-title">{{content.content_title}}</div>
            </div>

            <!-- Quick actions -->
            <div class="quick-actions">
                <button class="quick-action">{{quick_actions.quick_action1}}</button>
                <button class="quick-action">{{quick_actions.quick_action2}}</button>
                <button class="quick-action">{{quick_actions.quick_action3}}</button>
                <button class="quick-action">{{quick_actions.quick_action4}}</button>
                <button class="quick-action">{{quick_actions.quick_action5}}</button>
            </div>

            <!-- Chat container -->
            <div class="chat-container" id="chat-container">
                <div class="message ai-message">
                    {{content.welcome_message}}
                </div>
            </div>

            <!-- Input section -->
            <div class="input-container">
                <input type="text" class="chat-input" id="user-input" placeholder="{{content.input_placeholder}}">
                <button class="send-button" id="send-button">{{content.send_button_text}}</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration from template
        let API_KEY = '{{api_key}}';
        // Default values for model and temperature in case they're not in the configuration
        const MODEL = '{{ai_settings.model}}' === '{{ai_settings.model}}' ? 'mistral-large-latest' : '{{ai_settings.model}}';
        const TEMPERATURE = isNaN(parseFloat('{{ai_settings.temperature}}')) ? 0.7 : parseFloat('{{ai_settings.temperature}}');
        const SYSTEM_PROMPT = `{{ai_settings.system_prompt}}`;

        // Helper function to determine API base URL
        const getApiBaseUrl = () => {
            console.log('Determining API base URL...');
            console.log('Window location:', window.location.href);
            console.log('Is in iframe:', window !== window.parent);

            try {
                // First, check for the server-url meta tag (added by the server)
                const serverUrlMeta = document.querySelector('meta[name="server-url"]');
                if (serverUrlMeta && serverUrlMeta.getAttribute('content')) {
                    console.log('Using server-url from meta tag:', serverUrlMeta.getAttribute('content'));
                    return serverUrlMeta.getAttribute('content');
                }

                // SPECIAL CASE: If we're in a srcdoc iframe, we need to use the backend server directly
                if (window.location.href.startsWith('about:srcdoc')) {
                    console.log('Detected srcdoc iframe, using backend server directly');
                    return 'http://localhost:8000';
                }

                // Check if we're in an iframe (deployed app)
                if (window !== window.parent) {
                    // We're in an iframe, use the parent's origin
                    try {
                        // This will throw an error if cross-origin
                        const parentOrigin = window.parent.location.origin;
                        console.log('Using parent origin:', parentOrigin);

                        // If parent is on port 3000, switch to 8000 for API calls
                        if (parentOrigin.includes('localhost:3000')) {
                            console.log('Parent is on frontend server, switching to backend server');
                            return 'http://localhost:8000';
                        }

                        return parentOrigin;
                    } catch (e) {
                        // If we can't access parent origin, use the backend server
                        console.log('Cannot access parent origin, using backend server');
                        return 'http://localhost:8000';
                    }
                }

                // Check if we're in a production environment
                if (window.location.hostname !== 'localhost') {
                    console.log('In production environment, using current origin:', window.location.origin);
                    return window.location.origin;
                }

                // In development, always use localhost:8000 (backend server)
                console.log('In development environment, using backend server');
                return 'http://localhost:8000';
            } catch (e) {
                console.warn('Error determining API base URL:', e);
                // Fallback to a default URL based on environment
                try {
                    // Check if we're in a browser environment
                    if (typeof window !== 'undefined' && window.location && window.location.origin) {
                        if (window.location.hostname !== 'localhost') {
                            return window.location.origin;
                        }
                    }
                } catch (err) {
                    console.warn('Could not determine window origin:', err);
                }
                // Final fallback
                return 'http://localhost:8000';
            }
        };

        // Get app ID from URL path
        const getAppIdFromPath = () => {
            const pathParts = window.location.pathname.split('/');
            const slug = pathParts[pathParts.length - 1];
            return slug;
        };

        // Get the app ID from the template
        let APP_ID = '{{app_id}}';
        console.log('App ID from template:', APP_ID);

        // If the app_id is still a template placeholder (not replaced), get it from the URL
        if (APP_ID === '{{app_id}}' || APP_ID.includes('{{') || APP_ID.includes('}}')) {
            console.log('App ID is a template placeholder, trying to get it from URL');

            // Try to extract from URL path
            const urlPath = window.location.pathname;
            console.log('Current URL path:', urlPath);

            // First try to extract using regex to find rag-chatbot-XXX pattern
            const chatbotRegex = /rag-chatbot-(\d+)/;
            const chatbotMatch = urlPath.match(chatbotRegex);

            if (chatbotMatch && chatbotMatch[1]) {
                // We found a match like rag-chatbot-123, extract just the number
                APP_ID = chatbotMatch[1]; // Use the captured group (just the number)
                console.log('Extracted numeric app ID from URL path using regex:', APP_ID);
            } else {
                // Try to extract from URL query parameters
                const urlParams = new URLSearchParams(window.location.search);
                const appIdParam = urlParams.get('app_id');

                if (appIdParam && !isNaN(parseInt(appIdParam, 10))) {
                    APP_ID = appIdParam;
                    console.log('Using app_id from URL query parameter:', APP_ID);
                } else {
                    // Try to get from parent URL if in iframe
                    try {
                        if (window !== window.parent) {
                            const parentUrl = new URL(document.referrer);
                            const parentPath = parentUrl.pathname;
                            const parentMatch = parentPath.match(/rag-chatbot-(\d+)/);

                            if (parentMatch && parentMatch[1]) {
                                APP_ID = parentMatch[1];
                                console.log('Extracted app ID from parent URL:', APP_ID);
                            }
                        }
                    } catch (e) {
                        console.warn('Error accessing parent URL:', e);
                    }

                    // If still no valid app ID, try localStorage
                    if (APP_ID === '{{app_id}}' || APP_ID.includes('{{') || APP_ID.includes('}}')) {
                        const storedAppId = localStorage.getItem('rag_app_id');
                        if (storedAppId && !isNaN(parseInt(storedAppId, 10))) {
                            APP_ID = storedAppId;
                            console.log('Using app ID from localStorage:', APP_ID);
                        } else {
                            // Try to extract from URL path one more time
                            const pathMatch = window.location.pathname.match(/rag-chatbot-(\d+)/);
                            if (pathMatch && pathMatch[1]) {
                                APP_ID = pathMatch[1];
                                console.log('Using app ID extracted from URL path as fallback:', APP_ID);
                            } else if (window !== window.parent) {
                                // Try to extract from parent URL path
                                try {
                                    const parentPath = window.parent.location.pathname;
                                    const parentMatch = parentPath.match(/rag-chatbot-(\d+)/);
                                    if (parentMatch && parentMatch[1]) {
                                        APP_ID = parentMatch[1];
                                        console.log('Using app ID extracted from parent URL path as fallback:', APP_ID);
                                    }
                                } catch (e) {
                                    console.warn('Error accessing parent URL path:', e);
                                }
                            } else {
                                console.warn('Could not determine app ID from any source. RAG functionality may not work correctly.');
                            }
                        }
                    }
                }
            }

            // Store in localStorage for future use
            if (APP_ID && APP_ID !== '{{app_id}}' && !APP_ID.includes('{{') && !APP_ID.includes('}}')) {
                localStorage.setItem('rag_app_id', APP_ID);
            }
        }

        // Check if we have an API key
        console.log('Initial API key:', API_KEY ? (API_KEY.substring(0, 4) + '...') : 'none');

        // If no API key is available or it's still a template placeholder, try to get it from localStorage
        if (!API_KEY ||
            API_KEY === '{{api_key}}' ||
            API_KEY.includes('{{') ||
            API_KEY.includes('}}')) {

            // Try to get the API key from localStorage (for development/testing)
            const storedApiKey = localStorage.getItem('rag_api_key');
            if (storedApiKey) {
                console.log('Using API key from localStorage');
                API_KEY = storedApiKey;
            } else {
                console.warn('No API key available. Some features may not work correctly.');
                // For testing purposes, you can uncomment the following line to prompt for an API key
                // const promptedKey = prompt('Please enter your API key:');
                // if (promptedKey) {
                //     API_KEY = promptedKey;
                //     localStorage.setItem('rag_api_key', promptedKey);
                // }
            }
        }

        // Log configuration for debugging
        console.log('App configuration loaded:');
        console.log('- App ID:', APP_ID);
        console.log('- Model:', MODEL);
        console.log('- API Key available:', !!API_KEY &&
                                    API_KEY !== '{{api_key}}' &&
                                    !API_KEY.includes('{{') &&
                                    !API_KEY.includes('}}'));

        // Get the API base URL dynamically
        const apiBaseUrl = getApiBaseUrl();
        console.log('Using API base URL for API calls:', apiBaseUrl);

        // Construct the API URLs
        const COMPLETIONS_API_URL = `${apiBaseUrl}/api/v1/llm/completions`;
        const RAG_API_URL = `${apiBaseUrl}/api/v1/llm/rag`;

        // Construct the documents API URL using the app ID
        let DOCUMENTS_API_URL;

        // Get the app ID from the template - this is the correct ID set by the backend
        const templateAppId = '{{app_id}}';
        console.log('App ID from template (raw):', templateAppId);

        // Check if the template app ID is a valid number and not a placeholder
        if (templateAppId && !templateAppId.includes('{{') && !isNaN(parseInt(templateAppId, 10))) {
            // Use the app ID from the template
            DOCUMENTS_API_URL = `${apiBaseUrl}/api/v1/documents/app/id/${templateAppId}`;
            console.log('Documents API URL (using template app_id):', DOCUMENTS_API_URL);
        } else {
            // Log the app ID from the template for debugging
            console.log('Template app_id is not valid:', templateAppId);

            // Use the APP_ID variable as a fallback
            if (APP_ID && !isNaN(parseInt(APP_ID, 10))) {
                DOCUMENTS_API_URL = `${apiBaseUrl}/api/v1/documents/app/id/${APP_ID}`;
                console.log('Documents API URL (using APP_ID variable):', DOCUMENTS_API_URL);
            } else {
                console.warn('No valid app ID available for document retrieval');
                DOCUMENTS_API_URL = null;
            }
        }

        // DOM elements
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const quickActions = document.querySelectorAll('.quick-action');

        // Add event listeners
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Add event listeners to quick action buttons
        quickActions.forEach(button => {
            button.addEventListener('click', function() {
                userInput.value = this.textContent;
                sendMessage();
            });
        });

        // Function to send message
        async function sendMessage() {
            console.log('Send message function called');
            const message = userInput.value.trim();
            if (!message) {
                console.log('Message is empty, not sending');
                return;
            }

            console.log('Sending message:', message);

            // Add user message to chat
            addMessage(message, 'user');

            // Clear input
            userInput.value = '';

            try {
                // Show typing indicator
                const typingIndicator = document.createElement('div');
                typingIndicator.className = 'message ai-message';
                typingIndicator.id = 'typing-indicator';
                typingIndicator.textContent = '{{content.typing_indicator_text}}';
                chatContainer.appendChild(typingIndicator);

                // Scroll to bottom
                chatContainer.scrollTop = chatContainer.scrollHeight;

                // Get relevant document chunks for RAG
                let documentContext = '';
                try {
                    // Only try to fetch documents if we have a valid API key and a valid documents URL
                    if (API_KEY &&
                        API_KEY !== '{{api_key}}' &&
                        !API_KEY.includes('{{') &&
                        !API_KEY.includes('}}') &&
                        DOCUMENTS_API_URL) {
                        console.log('Fetching documents from:', DOCUMENTS_API_URL);
                        // Set up headers for the request
                        let headers = {
                            'Content-Type': 'application/json',
                            'X-API-Key': API_KEY  // Always include X-API-Key header
                        };

                        // Also include Authorization header for backward compatibility
                        headers['Authorization'] = `Bearer ${API_KEY}`;

                        console.log('Using headers for document retrieval:', Object.keys(headers));

                        const documentsResponse = await fetch(DOCUMENTS_API_URL, {
                            method: 'GET',
                            headers: headers
                        });

                        if (documentsResponse.ok) {
                            const documents = await documentsResponse.json();
                            if (documents && documents.length > 0) {
                                // In a real implementation, we would search for relevant chunks here
                                // For now, we'll just indicate that documents are available
                                documentContext = "The user has uploaded documents. Please use them to answer the question.";
                            } else {
                                documentContext = "{{content.no_documents_message}}";
                            }
                        } else {
                            console.warn(`Error fetching documents: ${documentsResponse.status}`);
                            documentContext = "Error fetching documents. Proceeding with general knowledge.";
                        }
                    } else if (!API_KEY) {
                        console.warn('No API key available for document retrieval');
                        documentContext = "No API key available. Proceeding with general knowledge.";
                    } else if (!DOCUMENTS_API_URL) {
                        console.warn('No valid documents URL available');
                        documentContext = "Could not determine app ID for document retrieval. Proceeding with general knowledge.";
                    }
                } catch (error) {
                    console.error('Error fetching documents:', error);
                    documentContext = "Error fetching documents. Proceeding with general knowledge.";
                }

                // The app_id should now be directly available from the template as a numeric ID
                console.log('Current APP_ID from template:', APP_ID);
                console.log('APP_ID type:', typeof APP_ID);

                // IMPORTANT: Always prioritize extracting app ID from the URL path
                const urlPath = window.location.pathname;
                const chatbotRegex = /rag-chatbot-(\d+)/;
                const chatbotMatch = urlPath.match(chatbotRegex);

                if (chatbotMatch && chatbotMatch[1]) {
                    const extractedId = parseInt(chatbotMatch[1], 10);
                    console.log('Extracted numeric app ID from URL path:', extractedId);

                    // Set APP_ID to the extracted numeric ID - this overrides any previous value
                    APP_ID = extractedId.toString();
                    console.log('Setting APP_ID to extracted value from URL path:', APP_ID);
                }

                // If in iframe, try to extract from parent URL
                try {
                    if (window !== window.parent) {
                        const parentUrl = document.referrer;
                        console.log('Parent URL:', parentUrl);

                        const parentMatch = parentUrl.match(/rag-chatbot-(\d+)/);
                        if (parentMatch && parentMatch[1]) {
                            const extractedId = parseInt(parentMatch[1], 10);
                            console.log('Extracted numeric app ID from parent URL:', extractedId);

                            // Set APP_ID to the extracted numeric ID
                            APP_ID = extractedId.toString();
                            console.log('Setting APP_ID to extracted value from parent URL:', APP_ID);
                        }
                    }
                } catch (e) {
                    console.warn('Error accessing parent URL:', e);
                }

                // IMPORTANT DEBUG: Log all configuration values to see what's being passed
                console.log('All template variables:');
                console.log('- API_KEY:', API_KEY ? (API_KEY.substring(0, 4) + '...') : 'none');
                console.log('- MODEL:', MODEL);
                console.log('- TEMPERATURE:', TEMPERATURE);
                console.log('- SYSTEM_PROMPT:', SYSTEM_PROMPT.substring(0, 50) + '...');
                console.log('- APP_ID:', APP_ID);

                // Convert to number if it's a string
                let numericAppId = (typeof APP_ID === 'string') ? parseInt(APP_ID, 10) : APP_ID;

                // Verify that we have a valid numeric ID
                if (isNaN(numericAppId)) {
                    console.warn('APP_ID is not a valid number:', APP_ID);

                    // Try to get from URL query parameter as fallback
                    const urlParams = new URLSearchParams(window.location.search);
                    const appIdParam = urlParams.get('app_id');
                    if (appIdParam && !isNaN(parseInt(appIdParam, 10))) {
                        numericAppId = parseInt(appIdParam, 10);
                        console.log('Using app_id from URL query parameter:', numericAppId);
                    } else {
                        // Last resort - prompt the user (for testing only)
                        const userInput = prompt('Please enter the app ID (numeric only).\n\nThis is needed for RAG functionality to work correctly.');
                        if (userInput && !isNaN(parseInt(userInput, 10))) {
                            numericAppId = parseInt(userInput, 10);
                            console.log('Using manually entered app ID:', numericAppId);
                        } else {
                            // Don't use a hardcoded default - extract from URL path
                            const pathMatch = window.location.pathname.match(/rag-chatbot-(\d+)/);
                            if (pathMatch && pathMatch[1]) {
                                numericAppId = parseInt(pathMatch[1], 10);
                                console.log('Using app ID extracted from URL path as fallback:', numericAppId);
                            } else {
                                // Absolute last resort - use a default but log a warning
                                console.warn('Could not determine app ID from any source. RAG functionality may not work correctly.');
                            }
                        }
                    }
                }

                console.log('Using numeric app ID for RAG request:', numericAppId);

                // Get the app slug - handle both direct access and iframe scenarios
                let appSlug;

                // Check if we're in an iframe
                if (window !== window.parent) {
                    try {
                        // Try to get the parent URL
                        const parentUrl = document.referrer;
                        console.log('Parent URL:', parentUrl);

                        if (parentUrl) {
                            // Extract the app slug from the parent URL
                            const urlObj = new URL(parentUrl);
                            const pathParts = urlObj.pathname.split('/');
                            // Find the part that matches the rag-chatbot pattern
                            for (const part of pathParts) {
                                if (part.startsWith('rag-chatbot-')) {
                                    appSlug = part;
                                    break;
                                }
                            }

                            // If we couldn't find it in the path parts, use the last part
                            if (!appSlug) {
                                appSlug = pathParts[pathParts.length - 1];
                            }

                            console.log('Extracted app slug from parent URL:', appSlug);
                        }
                    } catch (e) {
                        console.warn('Error accessing parent URL:', e);
                    }
                }

                // If we couldn't get the slug from the parent URL, try the current URL
                if (!appSlug || appSlug === 'srcdoc') {
                    const urlPath = window.location.pathname;
                    console.log('Current URL path:', urlPath);

                    // Try to extract using regex to find rag-chatbot-XXX pattern
                    const chatbotRegex = /rag-chatbot-\d+/;
                    const chatbotMatch = urlPath.match(chatbotRegex);

                    if (chatbotMatch) {
                        appSlug = chatbotMatch[0];
                        console.log('Extracted app slug using regex:', appSlug);
                    } else {
                        // Fallback to the last part of the URL path
                        appSlug = urlPath.split('/').pop();
                        console.log('Using last part of URL path as app slug:', appSlug);
                    }
                }

                // If we still have 'srcdoc' as the slug, try to extract from the parent URL path
                if (!appSlug || appSlug === 'srcdoc') {
                    try {
                        // Try to get the parent URL path
                        if (window !== window.parent && window.parent.location.pathname) {
                            const parentPath = window.parent.location.pathname;
                            console.log('Parent URL path:', parentPath);

                            // Try to extract using regex to find rag-chatbot-XXX pattern
                            const chatbotRegex = /rag-chatbot-\d+/;
                            const chatbotMatch = parentPath.match(chatbotRegex);

                            if (chatbotMatch) {
                                appSlug = chatbotMatch[0];
                                console.log('Extracted app slug from parent URL path:', appSlug);
                            }
                        }
                    } catch (e) {
                        console.warn('Error accessing parent URL path:', e);
                    }

                    // If we still don't have a valid app slug, prompt the user
                    if (!appSlug || appSlug === 'srcdoc') {
                        const userInput = prompt('Please enter your app slug (e.g., rag-chatbot-845):');
                        if (userInput) {
                            appSlug = userInput;
                            console.log('Using manually entered app slug:', appSlug);
                        } else {
                            // Use the app ID we extracted earlier if available
                            if (numericAppId && !isNaN(numericAppId)) {
                                appSlug = `rag-chatbot-${numericAppId}`;
                                console.log('Using app slug constructed from numeric app ID:', appSlug);
                            } else {
                                console.warn('Could not determine app slug from any source. RAG functionality may not work correctly.');
                            }
                        }
                    }
                }

                // Still allow override via URL parameter for testing
                const urlParams = new URLSearchParams(window.location.search);
                const urlAppId = urlParams.get('app_id');
                const urlAppSlug = urlParams.get('app_slug');

                // Prepare request body for RAG API
                const ragRequestBody = {
                    query: message,
                    temperature: TEMPERATURE,
                    model: MODEL,
                    top_k: parseInt('{{rag_settings.top_k_results}}') || 5,
                    similarity_threshold: parseFloat('{{rag_settings.similarity_threshold}}') || 0.7
                };

                // Get the app ID from the template - this is the correct ID set by the backend
                const templateAppIdForRequest = '{{app_id}}';
                console.log('App ID from template for request (raw):', templateAppIdForRequest);

                // Check if the template app ID is a valid number and not a placeholder
                if (templateAppIdForRequest && !templateAppIdForRequest.includes('{{') && !isNaN(parseInt(templateAppIdForRequest, 10))) {
                    // Use the app ID from the template
                    ragRequestBody.app_id = parseInt(templateAppIdForRequest, 10);
                    console.log('Using template app_id for request:', ragRequestBody.app_id);
                } else {
                    // Log the app ID from the template for debugging
                    console.log('Template app_id is not valid for request:', templateAppIdForRequest);

                    // Use the APP_ID variable as a fallback
                    if (APP_ID && !isNaN(parseInt(APP_ID, 10))) {
                        ragRequestBody.app_id = parseInt(APP_ID, 10);
                        console.log('Using APP_ID variable for request:', ragRequestBody.app_id);
                    } else {
                        // Hardcode the correct app ID as a last resort
                        ragRequestBody.app_id = 13;
                        console.log('Using hardcoded app_id (13) as last resort');
                    }
                }

                // Make API request
                let response;
                try {
                    // Check if we have a valid API key
                    if (!API_KEY) {
                        console.error('No API key available');
                        throw new Error('No API key available');
                    }

                    // Log that we have a valid API key
                    console.log('Using API key:', API_KEY.substring(0, 4) + '...');

                    // We'll use the parsed app ID from earlier

                    // Set up headers for the request
                    let headers = {
                        'Content-Type': 'application/json',
                        'X-API-Key': API_KEY  // Always include X-API-Key header
                    };

                    // Also include Authorization header for backward compatibility
                    headers['Authorization'] = `Bearer ${API_KEY}`;

                    console.log('Using headers for completion:', Object.keys(headers));

                    console.log('Making RAG API request to:', RAG_API_URL);
                    console.log('RAG Request body:', ragRequestBody);

                    // IMPORTANT DEBUG: Show the exact JSON being sent
                    console.log('RAG Request JSON:', JSON.stringify(ragRequestBody, null, 2));

                    // CRITICAL FIX: Always make the request directly to the backend server
                    // This ensures RAG functionality works correctly in all scenarios
                    console.log('Making RAG API request directly to backend server');

                    // Use the RAG API URL we constructed earlier
                    console.log('Making RAG API request to:', RAG_API_URL);

                    try {
                        response = await fetch(RAG_API_URL, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify(ragRequestBody),
                            // Important: Allow CORS for cross-origin requests
                            mode: 'cors',
                            credentials: 'include'
                        });
                        console.log('RAG API response status:', response.status);

                        // Handle 404 error (no documents found) by falling back to standard completions API
                        if (response.status === 404) {
                            console.log('No documents found for this app. Falling back to standard completions API.');

                            // Prepare request body for standard completions API
                            const completionsRequestBody = {
                                messages: [
                                    {
                                        role: "system",
                                        content: SYSTEM_PROMPT
                                    },
                                    {
                                        role: "user",
                                        content: message
                                    }
                                ],
                                temperature: TEMPERATURE,
                                model: MODEL,
                                max_tokens: 1000
                            };

                            console.log('Making standard completions API request to:', COMPLETIONS_API_URL);
                            console.log('Completions Request body:', completionsRequestBody);

                            // Make request to standard completions API
                            response = await fetch(COMPLETIONS_API_URL, {
                                method: 'POST',
                                headers: headers,
                                body: JSON.stringify(completionsRequestBody)
                            });

                            console.log('Completions API response status:', response.status);
                        }
                    } catch (fetchError) {
                        console.error('Error calling backend directly:', fetchError);
                        throw new Error('Failed to connect to backend server. Please make sure the server is running on port 8000.');
                    }

                    console.log('API response status:', response.status);

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Error making API request:', error);
                    throw error;
                }

                // Remove typing indicator
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    chatContainer.removeChild(indicator);
                }

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                console.log('API response data:', data);

                if (data.answer) {
                    // This is a RAG response
                    // Pass the sources to the addMessage function
                    addMessage(data.answer, 'ai', data.sources);

                    // Log sources for debugging
                    if (data.sources && data.sources.length > 0) {
                        console.log('Sources used for answer:', data.sources);
                    }
                } else if (data.choices && data.choices.length > 0) {
                    // This is a standard completions response
                    const aiMessage = data.choices[0].message.content;

                    // Add a note if we fell back to standard completions due to no documents
                    if (response.status === 200 && response.url.includes('/completions')) {
                        addMessage("I don't have any documents to reference for this app yet. Here's a general response:\n\n" + aiMessage, 'ai');
                    } else {
                        addMessage(aiMessage, 'ai');
                    }
                } else {
                    addMessage('{{content.no_response_text}}', 'ai');
                }
            } catch (error) {
                console.error('Error:', error);

                // Remove typing indicator
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    chatContainer.removeChild(indicator);
                }

                // Show error message
                addMessage('{{content.error_message}}', 'ai');
            }
        }

        // Function to add message to chat
        function addMessage(text, sender, sources = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;

            // Process markdown-like formatting
            let formattedText = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>')              // Italic
                .replace(/`(.*?)`/g, '<code>$1</code>')            // Code
                .replace(/\n/g, '<br>');                           // Line breaks

            messageDiv.innerHTML = formattedText;

            // Add sources if available (only for AI messages)
            if (sender === 'ai' && sources && sources.length > 0) {
                const sourcesContainer = document.createElement('div');
                sourcesContainer.className = 'sources-container';

                // Create toggle button for sources
                const sourcesToggle = document.createElement('div');
                sourcesToggle.className = 'sources-toggle';
                sourcesToggle.innerHTML = '📚 What is my answer based on?';
                sourcesToggle.addEventListener('click', function() {
                    const sourcesList = this.nextElementSibling;
                    sourcesList.classList.toggle('expanded');

                    // Change text based on expanded state
                    if (sourcesList.classList.contains('expanded')) {
                        this.innerHTML = '📚 Hide source documents';
                    } else {
                        this.innerHTML = '📚 What is my answer based on?';
                    }
                });

                // Create sources list
                const sourcesList = document.createElement('div');
                sourcesList.className = 'sources-list';

                // Add explanation heading
                const sourcesExplanation = document.createElement('div');
                sourcesExplanation.className = 'sources-explanation';
                sourcesExplanation.innerHTML = 'Below documents were used to generate this answer. Click on a document to see the specific paragraphs.';
                sourcesList.appendChild(sourcesExplanation);

                // Group sources by document name
                const groupedSources = {};

                sources.forEach((source, index) => {
                    // Get document name from metadata
                    const docName = source.metadata && source.metadata.document_name
                        ? source.metadata.document_name
                        : `Source ${index + 1}`;

                    // Create the group if it doesn't exist
                    if (!groupedSources[docName]) {
                        groupedSources[docName] = [];
                    }

                    // Add the source to its group
                    groupedSources[docName].push(source);
                });

                // Add each document group
                Object.entries(groupedSources).forEach(([docName, docSources]) => {
                    const sourceItem = document.createElement('div');
                    sourceItem.className = 'source-item';

                    // Create source name/header
                    const sourceName = document.createElement('div');
                    sourceName.className = 'source-name';

                    // Show document name with paragraph count
                    sourceName.innerHTML = `<span>${docName} (${docSources.length} ${docSources.length === 1 ? 'paragraph' : 'paragraphs'})</span><span>▼</span>`;

                    // Create container for all chunks from this document
                    const chunksContainer = document.createElement('div');
                    chunksContainer.className = 'source-chunks-container';

                    // Toggle chunks container visibility on click
                    sourceName.addEventListener('click', function() {
                        chunksContainer.classList.toggle('expanded');

                        // Change arrow direction
                        const arrow = this.querySelector('span:last-child');
                        if (chunksContainer.classList.contains('expanded')) {
                            arrow.textContent = '▲';
                        } else {
                            arrow.textContent = '▼';
                        }
                    });

                    // Add each chunk from this document
                    docSources.forEach((source, chunkIndex) => {
                        // Create chunk container
                        const chunkItem = document.createElement('div');
                        chunkItem.className = 'source-chunk';

                        // Add paragraph number if there are multiple paragraphs
                        if (docSources.length > 1) {
                            const chunkHeader = document.createElement('div');
                            chunkHeader.className = 'chunk-header';
                            chunkHeader.textContent = `Paragraph ${chunkIndex + 1}`;
                            chunkItem.appendChild(chunkHeader);
                        }

                        // Create source content with markdown formatting
                        const sourceContent = document.createElement('div');
                        sourceContent.className = 'source-content';

                        // Clean up the text - remove document IDs and clean up formatting
                        let cleanText = source.text;

                        // Remove document ID lines (lines starting with # followed by alphanumeric characters and hyphens)
                        cleanText = cleanText.replace(/^#\s*[a-zA-Z0-9\-]+\.pdf.*$/m, '');

                        // Apply the same markdown formatting we use for messages
                        let formattedSourceText = cleanText
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')              // Italic
                            .replace(/`(.*?)`/g, '<code>$1</code>')            // Code
                            .replace(/\n/g, '<br>');                           // Line breaks

                        // Remove any empty lines at the beginning
                        formattedSourceText = formattedSourceText.replace(/^(<br>)+/, '');

                        sourceContent.innerHTML = formattedSourceText;

                        // Add content to chunk
                        chunkItem.appendChild(sourceContent);

                        // Add chunk to chunks container
                        chunksContainer.appendChild(chunkItem);
                    });

                    // Add to source item
                    sourceItem.appendChild(sourceName);
                    sourceItem.appendChild(chunksContainer);

                    // Add to sources list
                    sourcesList.appendChild(sourceItem);
                });

                // Add toggle and list to container
                sourcesContainer.appendChild(sourcesToggle);
                sourcesContainer.appendChild(sourcesList);

                // Add sources container to message
                messageDiv.appendChild(sourcesContainer);
            }

            chatContainer.appendChild(messageDiv);

            // Scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    </script>
</body>
</html>
